Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `
    precision highp float;

    varying vec3 rayDir;

    uniform vec3 eyePos;
    uniform samplerCube envmapTexture;

    uniform mat4 quadrics[32];
    uniform vec4 brdfs[16];
    uniform vec4 lightPositions[8];
    uniform vec4 lightPowerDensities[8];

    float intersectClippedQuadric(mat4 A, mat4 B, vec4 e, vec4 d) {
        float a = dot(d * A, d);
        float b = dot(d * A, e) + dot(e * A, d);
        float c = dot(e * A, e);

        float disc = b*b-4.0*a*c;

        if(disc < 0.0) {
            return -1.0;
        }

        float t1 = (-1.0*b + sqrt(disc))/(2.0*a);
        float t2 = (-1.0*b - sqrt(disc))/(2.0*a);

        vec4 r1 = e + d * t1;
        vec4 r2 = e + d * t2;

        if(dot(r1 * B, r1) > 0.0) {
            t1 = -1.0;
        }

        if(dot(r2 * B, r2) > 0.0) {
            t2 = -1.0;
        }

        if(t1 > 0.0 && t1 < t2) return t1;
        if(t2 > 0.0 && t2 < t1) return t2;
        if(t1 > 0.0) return t1;
        return t2;
    }

    bool findBestHit(vec4 e, vec4 d,
    out float bestT, out vec4 bestBrdf, out mat4 bestA) {
        bestT = 9000.0;

        for(int i=0; i<16; i++) {
            float currentT = intersectClippedQuadric(quadrics[i*2], quadrics[i*2+1], e, d);

            if(currentT < bestT && currentT > 0.0) {
                bestT = currentT;
                bestBrdf = brdfs[i];
                bestA = quadrics[i*2];
            }
        }

        if(bestT < 9000.0) {
            return true;
        }
        return false;
    }

    void main(void) {
        vec4 e = vec4(eyePos, 1);
        vec4 d = vec4(normalize(rayDir), 0);

        vec3 contrib = vec3(1, 1, 1);
        vec4 color = vec4(0, 0, 0, 1);

        for(int i=0; i<5; i++) {
            float t;
            vec4 brdf;
            mat4 a;

            bool hitFound = findBestHit(e, d, t, brdf, a);

            if(!hitFound) {
                color += textureCube(envmapTexture, d.xyz) * vec4(contrib, 1);
                break;
            } else {
                e = e + d*t; // update ray origin
                vec4 d = vec4(normalize((e*a+e*a).xyz), 0); // update ray direction
                // e += d*0.01; // prevent surface acne


                if(dot(d, vec4(normalize(rayDir), 0)) > 0.0) {
                    d *= -1.0;
                }

                if(brdf.a == 0.0) {
                    // Lambertian
                    for(int j=0; j<8; j++) {
                        if(lightPowerDensities[j].r == 0.0 && lightPowerDensities[j].g == 0.0 && lightPowerDensities[j].b == 0.0) {
                            continue;
                        }

                        vec4 colorDiff = lightPowerDensities[j] * brdf * dot(d, normalize(lightPositions[j] - e));
                        color += colorDiff;

                        vec4 shadowRayDir = e - lightPositions[j];
                        float shadowT; vec4 throwaway1; mat4 throwaway2;
                        findBestHit(lightPositions[j], shadowRayDir, shadowT, throwaway1, throwaway2);
                        vec4 shadowHit = lightPositions[j] + shadowRayDir * shadowT;
                        vec4 shadowHitDistance = (shadowHit - e);
                        if(length(shadowHitDistance) > 0.1) {
                            color -= colorDiff;
                        }
                    }

                    gl_FragColor = color;
                    return;
                // } else if (brdf.a < 200.0) {
                //     // Phong-Blinn
                //     for(int j=0; j<8; j++) {
                //         if(lightPowerDensities[j].r == 0.0 && lightPowerDensities[j].g == 0.0 && lightPowerDensities[j].b == 0.0) {
                //             continue;
                //         }

                //         vec4 halfDir = normalize(normalize(lightPositions[j] - e) + vec4(normalize(rayDir), 0));
                //         float specAngle = max(dot(halfDir, d), 0.0);
                //         float specular = pow(specAngle, 16.0);

                //         vec4 colorDiff = lightPowerDensities[j] * brdf * dot(d, normalize(lightPositions[j] - e)) + specular * brdf;
                //         color += colorDiff;

                //         vec4 shadowRayDir = e - lightPositions[j];
                //         float shadowT; vec4 throwaway1; mat4 throwaway2;
                //         findBestHit(lightPositions[j], shadowRayDir, shadowT, throwaway1, throwaway2);
                //         vec4 shadowHit = lightPositions[j] + shadowRayDir * shadowT;
                //         vec4 shadowHitDistance = (shadowHit - e);
                //         if(length(shadowHitDistance) > 0.1) {
                //             color -= colorDiff;
                //         }
                //     }

                //     gl_FragColor = color;
                //     return;
                } else if (brdf.a >= 200.0) {
                    color += vec4(brdf.rgb * contrib, 1);
                    contrib *= brdf.rgb;
                    e = e + d*t;
                    d = vec4(normalize((e*a+e*a).xyz), 0);
                    e += d*0.101;

                    if(contrib.r < 0.1 && contrib.g < 0.1 && contrib.b < 0.1) {
                        // gl_FragColor = color;
                        break;
                    }
                }
            }
        }
        gl_FragColor = vec4(color.rgb, 1);
        return;

        //     float t; vec4 brdf; mat4 a;
        //     bool hitFound = findBestHit(e, d, t, brdf, a);
        //     if(!hitFound) {
        //         color += textureCube(envmapTexture, d.xyz);
        //         break;
        //     } else {
        //         color += vec4(brdf.rgb, 1) * vec4(contrib, 1);
        //         contrib *= brdf.rgb;
        //         e = e + d*t;
        //         vec4 previousD = d;
        //         d = vec4(normalize((e*a+e*a).xyz), 0);

        //         e += d*0.101;

        //         if(brdf.a < 200.0/255.0) {
        //             // for(int i=0; i<8; i++) {
        //             //     if(lightPositions[i] != vec4(0, 0, 0, 0)) {
        //             //         color += brdf * dot(d, lightPositions[i]);
        //             //     }
        //             // }

        //             break;
        //         }

        //         if(contrib.r < 0.1 && contrib.g < 0.1 && contrib.b < 0.1) {
        //             break;
        //         }
        //     }
        // }
        // gl_FragColor = color;
    }
`;