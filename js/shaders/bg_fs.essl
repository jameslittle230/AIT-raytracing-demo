Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `
    precision highp float;

    varying vec3 rayDir;

    uniform vec3 eyePos;
    uniform samplerCube envmapTexture;

    uniform mat4 quadrics[32];
    uniform vec4 brdfs[16];
    uniform vec4 lightPositions[8];
    uniform vec4 lightPowerDensities[8];

    float intersectClippedQuadric(mat4 A, mat4 B, vec4 e, vec4 d) {
        float a = dot(d * A, d);
        float b = dot(d * A, e) + dot(e * A, d);
        float c = dot(e * A, e);

        float disc = b*b-4.0*a*c;

        if(disc < 0.0) {
            return -1.0;
        }

        float t1 = (-1.0*b + sqrt(disc))/(2.0*a);
        float t2 = (-1.0*b - sqrt(disc))/(2.0*a);

        vec4 r1 = e + d * t1;
        vec4 r2 = e + d * t2;

        if(dot(r1 * B, r1) > 0.0) {
            t1 = -1.0;
        }

        if(dot(r2 * B, r2) > 0.0) {
            t2 = -1.0;
        }

        if(t1 > 0.0 && t1 < t2) return t1;
        if(t2 > 0.0 && t2 < t1) return t2;
        if(t1 > 0.0) return t1;
        return t2;
    }

    bool findBestHit(vec4 e, vec4 d,
    out float bestT, out vec4 bestBrdf, out mat4 bestA) {
        bestT = 9000.0;

        for(int i=0; i<16; i++) {
            float currentT = intersectClippedQuadric(quadrics[i*2], quadrics[i*2+1], e, d);

            if(currentT < bestT && currentT > 0.0) {
                bestT = currentT;
                bestBrdf = brdfs[i];
                bestA = quadrics[i*2];
            }
        }

        if(bestT < 9000.0) {
            return true;
        }
        return false;
    }

    void main(void) {
        vec4 e = vec4(eyePos, 1);
        vec4 d = vec4(normalize(rayDir), 0);

        vec3 contrib = vec3(1, 1, 1);
        vec4 color = vec4(0, 0.3, 0.3, 1);

        for(int i=0; i<5; i++) {
            float t;
            vec4 brdf;
            mat4 a;

            if(findBestHit(e, d, t, brdf, a)) {
                e = e + d*t; // update ray origin
                vec4 d = vec4(normalize((e*a+e*a).xyz), 0); // update ray direction
                // e += d*0.01; // prevent surface acne


                if(dot(d, vec4(normalize(rayDir), 0)) > 0.0) {
                    d *= -1.0;
                }

                if(brdf.a == 0.0) {
                    // diffuse color
                    color = lightPowerDensities[0] * brdf * dot(d, normalize(lightPositions[0] - e));
                    break;
                } else if (brdf.a < 200.0) {
                    // diffuse but shiny
                } else if (brdf.a >= 200.0) {
                    // mirror surface
                }
                // color = vec4(d.xyz, 1);
            }
        }

        //     float t; vec4 brdf; mat4 a;
        //     bool hitFound = findBestHit(e, d, t, brdf, a);
        //     if(!hitFound) {
        //         color += textureCube(envmapTexture, d.xyz);
        //         break;
        //     } else {
        //         color += vec4(brdf.rgb, 1) * vec4(contrib, 1);
        //         contrib *= brdf.rgb;
        //         e = e + d*t;
        //         vec4 previousD = d;
        //         d = vec4(normalize((e*a+e*a).xyz), 0);

        //         e += d*0.101;

        //         if(brdf.a < 200.0/255.0) {
        //             // for(int i=0; i<8; i++) {
        //             //     if(lightPositions[i] != vec4(0, 0, 0, 0)) {
        //             //         color += brdf * dot(d, lightPositions[i]);
        //             //     }
        //             // }

        //             break;
        //         }

        //         if(contrib.r < 0.1 && contrib.g < 0.1 && contrib.b < 0.1) {
        //             break;
        //         }
        //     }
        // }
        // gl_FragColor = color;
        gl_FragColor = vec4(color.rgb, 1);
    }
`;